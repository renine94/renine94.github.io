---
layout: single

header:
  teaser: /assets/images/logo/book.jpg
  overlay_image: /assets/images/logo/book.jpg
  overlay_filter: linear-gradient(rgba(255, 0, 0, 0.5), rgba(0, 255, 255, 0.5))
  caption: "Photo credit: [**Unsplash**](https://unsplash.com)"
  actions:
    - label: "Github"
      url: "https://github.com/renine94"

title: "면접을 위한 CS 전공지식 노트 (1) - 싱글톤 패턴"
excerpt: "🚀🚀 디자인 패턴과 프로그래밍 패러다임"

categories: book
tag: [cs]

toc: true
toc_label: "📕 목차"
toc_icon: "null"
toc_sticky: true

sidebar:
  nav: "docs"
---

**[알림]** 책에 대한 정보는 [여기](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=292815727) 를 참고해주세요.🚀🚀
{: .notice--danger}



# 01. 디자인 패턴

<div class="notice--success">
  <ul>
    <li> 프로그램을 설계할때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결 할 수 있도록 하나의 규약 형태로 만들어 놓은 것 </li>
  </ul>
</div>



## 1.1 싱글톤 패턴

> 싱글톤 패턴(Singleton pattern)은 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴이다.
>
> 보통 데이터베이스 연결 모듈에 많이 사용

- 인스턴스를 생성할 때 드는 비용이 줄어드는 장점이 있다.
- 하지만 의존성이 높아진다는 단점이 있다.



### 구현

#### JS

```js
const obj = {
  a: 27
}

const obj2 = {
  a: 27
}

console.log(obj === obj2)
// false
```

위의 코드에서 볼 수 있듯이 `obj` 와 `obj2` 는 서로 다른 인스턴스를 가진다.

```js
class Singleton {
  
  constructor() {
    if (!Singleton.instance) {
      Singleton.instance = this
    }
    return Singleton.instance
  }
  
  getInstance() {
    return this.instance
  }
}

const a = new Singleton()
const b = new Singleton()
console.log(a === b) // true
```



앞의 코드는 `Singleton.instance` 라는 하나의 인스턴스를 가지는 Singleton 클래스를 구현한 모습

이를 통해 a와 b는 하나의 인스턴스를 가집니다.

#### Python

```python
class Singleton(object):
    def __new__(cls):
        if not hasattr(cls,'instance'):
            print('create')
            cls.instance = super(Singleton, cls).__new__(cls)
        else:
            print('recycle')
        return cls.instance
 
s1 = Singleton() # create
s2 = Singleton() # recycle
print(s1 == s2) # true

```

#### Java

```java
class Singleton {
  private static class singleInstanceHolder {
    private static final Singleton INSTANCE = new Singleton();
  }
  
  public static synchronized Singleton getInstance() {
    return singleInstanceHolder.INSTANCE;
  }
}

public class HelloWorld {
  public static void main(String[] args) {
    Singleton a = Singleton.getInstance();
    Singleton b = Singleton.getInstance();
    System.out.println(a.hashCode());
    System.out.println(b.hashCode());
    
    if (a == b) {
      System.out.println(true);
    }
  }
}

// 705927765
// 705927765
// true
```



**데이터 베이스 연결 모듈**에 자주 쓰이는 패턴이다.



### 단점

싱글톤 패턴은 TDD 할 때 걸림돌이 된다. TDD를 할 때 단위 테스트를 주로 하는데, 단위 테스트는 테스트가 서로 독립적이어야 하며, 테스트를 어떤 순서로든 실행할 수 있어야 합니다.

하지만 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 `독립적인` 인스턴스를 만들기가 어렵습니다.



### 의존성 주입

- 싱글톤 패턴은 사용하기 쉽고, 굉장히 실용적
- 모듈간의 결합을 강하게 만드는 단점
- 의존성 주입(DI) 을 통해 모듈간의 결합을 느슨하게 만들어 해결 가능

메인 모듈이 직접 다른 하위 모듈에 대한 의존성을 주기보다는 중간에 의존성 주입자(dependency injector)가 이 부분을 가로채 메인 모듈이 간접적으로 의존성을 주입하는 방식



이를 통해 메인 모듈(상위 모듈)은 하위 모듈에 대한 의존성이 떨어지게 됩니다.참고로 이를 `디커플링` 이 된다. 라고도 합니다.



- DI 장점

  - 모듈들을 쉽게 교체할 수 있는 구조

  - 쉽게 테스팅 하기 쉽고 마이그레이션 하기도 수월

  - 구현할 때 추상화 레이러를 넣고 이를 기반으로 구현체를 넣어 주기 때문에 애플리케이션

    방향이 일관되고, 쉽게 추론

  - 모듈 간 관계들이 명확해진다.

- DI 단점

  - 모듈들이 더욱 분리
  - 클래스 수가 늘어나 복잡성 증가
  - 약간의 런타임 패널티

- DI 원칙

  - 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않는다.
  - 둘 다 추상화에 의존해야 하며, 이때 추상화는 세부 사항에 의존하지 않는다.

